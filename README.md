# Matrix



Алгоритм  = волновой алгоритм + перебор с возвратом.

Алгоритм:

1. берем 1ю точку матрицы(Field[0][0])(точки будем перебирать циклами), Sum присваиваем значение Field[0][0];
2. каждую точку будем проверять на сумму с соседними с ней. Поэтому для каждой точки всего существует 4 точки - :
<i-1, y>
<i, y-1>
<i, y+1>
<i+1, y>
Эти значения будут храниться в стеке. - StackLines, StackColumns
Дополнительно создаем стек для хранения counter, где counter - счетчик точек(после использования точки, counter нужно уменьшить на 1, когда counter ==0, это значит, что точек вокруг основной точки для проверки больше нет, значит надо вернуться к предыдущей точке)
Работали с методом MethodPush(int const i, int const j);

3. в Method :

1. сохраняем текущую точку (StLine.push(Line), StColumn.push(Column) );
2. BoolField[Line][Column] присваеваем 0(значит, что поле занято);
3. Методы IfCanCheckThisCell(LineStack, ColumnStack);
		и IfCanntCheckCell(LineStack, ColumnStack, Sum, Line, Column); - методы, которые считают, есть ли еще точки для проверки(если counter==0, точек нет, возвращаемся на предыдущее поле), если точки есть - идем дальше
		
4. Check(LineStack, ColumnStack, BoolField)) - проверяет, занято ли поле(при помощи BoolField), и нет ли выхода за пределы поля
5. подсчитываем сумму текущей точки с соседней;
6. vecLines и vecColumns - это вектора, которые запоминают номер линии и строки с удачными ходами(значения пригодятся при подсчете результата)
7. IfSumIsEqualToTen(LineStack, ColumnStack, Line, Column, Sum); если сумма == 10, то FindMaxResult();
		SaveAllToFile(); тут называния говорят, что делаю)))
		после чего надо вернуться к предыдущему полю. Вот тут стеки и нужны. Возвращаем все, предварительно запомнив Line и Column
		возвращаемся к предыдущей сумме.
		
8. IfSumGreaterThatTen(int const& LineStack, int const& ColumnStack, int &Line, int &Column, int &Sum);
		тут то же, что при Sum==10, но запоминать результат и считать результат не нужно
		
9. если сумма меньше 10, то отмечаем точку как просмотренную, для текущей точки создаем 4 дополнительные точки, которые надо будет проверить(MethodPush) и рекурсивно возвращаемся в начало.

10. когда проверять больше нечего, все точки на Field[0][0] проверены, возвращаемся в метод Main, переходим в точку Field[0][1] , предварительно очистив все стеки и заполнив стек 4мя точками для проверки.



НА КОНСОЛЬ ВЫВОД ТОЛЬКО НАЧАЛЬНОГО ПОЛЯ И ЛУЧШЕГО РЕЗУЛЬТАТА(задание 2).
В ФАЙЛЕ - ВЫВОД ВСЕГО(задание 1 + 2). 

При выводе результатов - точки, которые в итоге в сумме дадут 10 - напечатаны обычно, остальные меняю на нули.

т.е. например

123

231

312

будет напечатано так:

123

001

012

result is:  123121
или 
result is:  121321
)))

